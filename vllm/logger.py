# Copyright Â© [2023,] 2023, Oracle and/or its affiliates.
"""Logging configuration for vLLM."""
import inspect
import json
import logging
import os
import sys
import time
import traceback
from pathlib import Path

from loguru import logger

VLLM_CONFIGURE_LOGGING = int(os.getenv("VLLM_CONFIGURE_LOGGING", "1"))


class InterceptHandler(logging.Handler):
    """A custom logging handler for intercepting logs and redirecting them.

    This handler is designed to integrate with loguru's `logger` library,
    capturing log records generated by Python's standard logging module and
    processing them using `logger`.

    Attributes:
        loglevel_mapping (dict): Mapping of logging level numbers to string
        representations.
    """
    loglevel_mapping = {
        50: "CRITICAL",
        40: "ERROR",
        30: "WARNING",
        20: "INFO",
        10: "DEBUG",
        0: "NOTSET",
    }

    def emit(self, record: logging.LogRecord):
        """Process the logging record.

        Overrides the default emit method to handle log records. It binds the
        logger to a specific name and adds contextual information.

        Args:
            record (logging.LogRecord): The log record to process.
        """
        try:
            level = logger.level(record.levelname).name
        except AttributeError:
            level = self.loglevel_mapping[record.levelno]

        frame, depth = inspect.currentframe(), 0
        while frame and (depth == 0
                         or frame.f_code.co_filename == logging.__file__):
            frame = frame.f_back
            depth += 1

        logger.opt(depth=depth,
                   exception=record.exc_info).log(level, record.getMessage())


class CustomizeLogger:
    """A class for configuring and customizing logging.

    Provides methods for setting up structured and unstructured logging,
    including log rotation, retention, and formatting.

    Methods are class methods, allowing direct access without instantiation.
    """

    @classmethod
    def make_logger(cls, config_path: Path):
        """Create and configure a logger based on a configuration file.

        Args:
            config_path (Path): Path to the configuration file.

        Returns:
            Logger: Configured logger instance.
        """
        config = cls.load_logging_config(config_path)
        logging_config = config.get("logger")

        logger = cls.customize_logging(
            structured_filepath=logging_config.get("structured_log_file_path"),
            unstructured_filepath=logging_config.get(
                "unstructured_log_file_path"),
            level=logging_config.get("level"),
            retention=logging_config.get("retention"),
            rotation=logging_config.get("rotation"),
            format=logging_config.get("format"),
        )

        return logger

    @classmethod
    def serialize(cls, record):
        """Serialize a log record to JSON.

        Args:
            record (dict): The log record to serialize.

        Returns:
            str: The serialized JSON string.
        """

        def format_exception(ex):
            """Format exception to include the entire traceback chain."""
            lines = []
            while ex:
                lines.extend(traceback.format_exception_only(ex.__class__, ex))
                tb = ex.__traceback__
                while tb:
                    lines.extend(traceback.format_tb(tb))
                    tb = tb.tb_next
                ex = ex.__cause__ or ex.__context__

            return ''.join(lines)

        exception = record["exception"]
        error = ""
        if exception:
            _, ex, _ = exception
            error = f" {ex.__class__.__name__}: {ex}\n{format_exception(ex)}"

        subset = {
            "module": record["module"],
            "pathname": record["file"].name,
            "lineno": record["line"],
            "thread": record["thread"].id,
            "extra_info": record["extra"],
            "funcName": record["function"],
            "ts": int(time.time() * 1000),
            "level": record["level"].name,
            "msg": record["message"] + error,
        }
        return json.dumps(subset)

    @classmethod
    def formatter(cls, record):
        """Format a log record for structured logging.

        Note: This function returns the string to be formatted, not the actual
        message to be logged.

        Args:
            record (dict): The log record to format.

        Returns:
            str: The formatted log record.
        """
        record["extra"]["serialized"] = cls.serialize(record)
        return "{extra[serialized]}\n"

    @classmethod
    def customize_logging(
        cls,
        structured_filepath: Path = None,
        unstructured_filepath: Path = None,
        level: str = 'INFO',
        rotation: str = None,
        retention: str = None,
        format: str = None,
    ):
        """Customize logging setup based on configuration options.

        Configures logging with options for both structured and unstructured
        log files, including rotation, retention, and formatting. Allows
        enabling/disabling file logging and structured logging.

        Args:
            structured_filepath (Path): Path to the structured log file.
            unstructured_filepath (Path): Path to the unstructured log file.
            level (str): Logging level.
            rotation (str): Log rotation policy.
            retention (str): Log retention policy.
            format (str): Log format.

        Returns:
            Logger: Configured logger instance.
        """
        logger.remove()

        # Console output configuration
        logger.add(
            sys.stderr,
            enqueue=True,
            backtrace=True,
            level=level.upper(),
            format=format,
        )

        # File logging configuration
        if unstructured_filepath:
            # Unstructured file logging configuration
            logger.add(
                str(unstructured_filepath),
                rotation=rotation,
                retention=retention,
                enqueue=True,
                backtrace=True,
                level=level.upper(),
                serialize=False,
                format=format,
            )
        if structured_filepath:
            # Structured file logging configuration
            logger.add(
                str(structured_filepath),
                rotation=rotation,
                retention=retention,
                enqueue=True,
                backtrace=True,
                level=level.upper(),
                serialize=False,
                format=cls.formatter,
            )

        # Basic configuration for intercepting standard logging messages
        logging.basicConfig(handlers=[InterceptHandler()], level=0)

        return logger.bind(name="vllm")

    @classmethod
    def load_logging_config(cls, config_path: Path):
        """Load logging configuration from a JSON file.

        Args:
            config_path (Path): Path to the configuration file.

        Returns:
            dict: Loaded configuration.
        """
        config = None
        with open(config_path) as config_file:
            config = json.load(config_file)
        return config


dir_path = os.path.dirname(os.path.realpath(__file__))
default_config_path = f"{dir_path}/default_logging_config.json"
config_path = Path(os.getenv("VLLM_LOGGING_CONFIG_PATH", default_config_path))
_root_logger = None

if VLLM_CONFIGURE_LOGGING:
    _root_logger = CustomizeLogger.make_logger(config_path)
else:
    _root_logger = logging.getLogger("vllm")


def init_logger(name: str):
    if VLLM_CONFIGURE_LOGGING:
        return _root_logger.bind(name=name)
    else:
        _logger = logging.getLogger(name)
        _logger.setLevel(os.getenv("LOG_LEVEL", "DEBUG"))
        return _logger
