name: Label issues based on keywords
on:
  issues:
    types: [opened, edited, reopened]
permissions:
  issues: write          # needed so the workflow can add labels
  contents: read
concurrency:
  group: issue-labeler-${{ github.event.issue.number }}
  cancel-in-progress: true
jobs:
  add-labels:
    runs-on: ubuntu-latest
    steps:
      - name: Label issues based on keywords
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
        with:
          script: |
            // Configuration: Add new labels and keywords here
            const labelConfig = {
              rocm: {
                // Keyword search - matches whole words only (with word boundaries)
                keywords: [
                  // Core ROCm/AMD terms
                  "rocm",
                  "amd",
                  "hip",
                  // GPU Models - Instinct Series
                  "amd instinct",
                  "mi300",
                  "mi300x",
                  "mi300a",
                  "mi250x",
                  "mi250",
                  "mi210x",
                  "mi210",
                  "mi325x",
                  "mi350x",
                  "mi355x",
                  // GPU Models - Radeon Series
                  "radeon",
                  "r9700",
                  "rx 9070",
                  "rx 9060",
                  "rx 7900",
                  "rx 7800",
                  // GPU Models - Pro Series
                  "w7900",
                  "w7800",
                  "w7700",
                  "v710",
                  "v620",
                  "w6800",
                  // Libraries and tools
                  "composable kernel",
                  "rccl",
                  "migraphx",
                  "hipgraph",
                  "pytorch",
                  "cuda",
                ],
                
                // Substring search - matches anywhere in text (partial matches)
                substrings: [
                  // Version patterns
                  "rocm-",           // matches rocm-5.7, rocm-6.0, etc.
                  "rocm_",           // matches rocm_5_7, etc.
                  "hip-",            // matches hip-config, etc.
                  
                  // Architecture prefixes
                  "gfx",             // matches gfx942, gfx90a, etc.
                  "cdna",            // matches cdna2, cdna3, etc.
                  "rdna",            // matches rdna2, rdna3, etc.
                  
                  // Library patterns
                  "torch_hip",       // matches pytorch_hip, torch_hip_extension, etc.
                  "_hip",            // matches any_hip, torch_hip, etc.
                  "hip_",            // matches hip_version, hip_runtime, etc.
                  
                  // ROCm tools and libraries
                  "hipify",          // matches hipify-perl, hipify-clang, etc.
                  
                  // Error patterns
                  "hipError",        // matches hipErrorMemoryFree, etc.
                  "rocm error",      // matches various rocm error messages
                  "amd gpu",         // matches "amd gpu driver", etc.
                ],
              },
            };
            
            // Helper function to remove only the collect_env.py details section
            function removeCollectEnvDetails(text) {
              // Pattern to match the specific collect_env.py details section
              // This looks for <details> tags that contain "python collect_env.py" in the summary
              const collectEnvPattern = /<details[\s\S]*?<summary>[\s\S]*?python collect_env\.py[\s\S]*?<\/summary>[\s\S]*?<\/details>/gi;
              
              // Alternative patterns in case the format varies slightly
              const alternativePatterns = [
                // Pattern for "The output of python collect_env.py"
                /<details[\s\S]*?<summary>[\s\S]*?output of[\s\S]*?python collect_env\.py[\s\S]*?<\/summary>[\s\S]*?<\/details>/gi,
                // Pattern for "collect_env.py output"
                /<details[\s\S]*?<summary>[\s\S]*?collect_env\.py[\s\S]*?output[\s\S]*?<\/summary>[\s\S]*?<\/details>/gi,
                // Pattern for environment information
                /<details[\s\S]*?<summary>[\s\S]*?environment[\s\S]*?information[\s\S]*?<\/summary>[\s\S]*?<\/details>/gi,
              ];
              
              let result = text;
              
              // Try the main pattern first
              result = result.replace(collectEnvPattern, '');
              
              // Try alternative patterns if the main one didn't match
              for (const pattern of alternativePatterns) {
                result = result.replace(pattern, '');
              }
              
              return result;
            }
            
            // Helper function to create regex based on search type
            function createSearchRegex(term, type) {
              // Escape special regex characters in the term
              const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              
              switch (type) {
                case 'keyword':
                  // Word boundary search - matches whole words only
                  return new RegExp(`\\b${escapedTerm}\\b`, "gi");
                case 'substring':
                  // Substring search - matches anywhere in the text
                  return new RegExp(escapedTerm, "gi");
                default:
                  throw new Error(`Unknown search type: ${type}`);
              }
            }
            
            // Helper function to find matching terms in text with line information
            function findMatchingTermsWithLines(text, keywords = [], substrings = []) {
              const matches = [];
              const lines = text.split('\n');
              
              // Process keyword searches
              for (const term of keywords) {
                const regex = createSearchRegex(term, 'keyword');
                const termMatches = [];
                
                // Check each line for matches
                lines.forEach((line, lineIndex) => {
                  const lineMatches = line.match(regex);
                  if (lineMatches) {
                    lineMatches.forEach(match => {
                      termMatches.push({
                        match: match,
                        lineNumber: lineIndex + 1,
                        lineContent: line.trim(),
                        searchType: 'keyword',
                        originalTerm: term,
                        // Show context around the match in the line
                        context: line.length > 100 ? 
                          line.substring(Math.max(0, line.toLowerCase().indexOf(match.toLowerCase()) - 30), 
                                       line.toLowerCase().indexOf(match.toLowerCase()) + match.length + 30) + '...' 
                          : line.trim()
                      });
                    });
                  }
                });
                
                if (termMatches.length > 0) {
                  matches.push({
                    term: term,
                    searchType: 'keyword',
                    matches: termMatches,
                    count: termMatches.length
                  });
                }
              }
              
              // Process substring searches
              for (const term of substrings) {
                const regex = createSearchRegex(term, 'substring');
                const termMatches = [];
                
                // Check each line for matches
                lines.forEach((line, lineIndex) => {
                  const lineMatches = line.match(regex);
                  if (lineMatches) {
                    lineMatches.forEach(match => {
                      termMatches.push({
                        match: match,
                        lineNumber: lineIndex + 1,
                        lineContent: line.trim(),
                        searchType: 'substring',
                        originalTerm: term,
                        // Show context around the match in the line
                        context: line.length > 100 ? 
                          line.substring(Math.max(0, line.toLowerCase().indexOf(match.toLowerCase()) - 30), 
                                       line.toLowerCase().indexOf(match.toLowerCase()) + match.length + 30) + '...' 
                          : line.trim()
                      });
                    });
                  }
                });
                
                if (termMatches.length > 0) {
                  matches.push({
                    term: term,
                    searchType: 'substring',
                    matches: termMatches,
                    count: termMatches.length
                  });
                }
              }
              
              return matches;
            }
            
            // Helper function to check if label should be added
            async function processLabel(labelName, config) {
              const body = context.payload.issue.body || "";
              const title = context.payload.issue.title || "";
              
              // Remove only the collect_env.py details section, keep other details
              const textWithoutCollectEnv = removeCollectEnvDetails(title + " " + body);
              
              core.notice(`Original text length: ${(title + " " + body).length}`);
              core.notice(`Text after removing collect_env details: ${textWithoutCollectEnv.length}`);
              
              let shouldAddLabel = false;
              let reason = '';
              
              // Check for terms in the remaining text (including other details sections)
              if (textWithoutCollectEnv) {
                const keywords = config.keywords || [];
                const substrings = config.substrings || [];
                
                core.notice(`Searching with ${keywords.length} keywords and ${substrings.length} substrings`);
                
                const matchingTerms = findMatchingTermsWithLines(textWithoutCollectEnv, keywords, substrings);
                if (matchingTerms.length > 0) {
                  core.notice(`Found ${matchingTerms.length} matching term(s):`);
                  
                  for (const termMatch of matchingTerms) {
                    core.notice(`  📍 Term: "${termMatch.term}" (${termMatch.searchType} search) found ${termMatch.count} time(s):`);
                    
                    // Show details for each match
                    termMatch.matches.forEach((match, index) => {
                      core.notice(`    ${index + 1}. Line ${match.lineNumber}: "${match.match}" [${match.searchType}]`);
                      core.notice(`       Context: ${match.context}`);
                      if (match.lineContent !== match.context) {
                        core.notice(`       Full line: ${match.lineContent}`);
                      }
                    });
                  }
                  
                  shouldAddLabel = true;
                  const totalMatches = matchingTerms.reduce((sum, t) => sum + t.count, 0);
                  const keywordMatches = matchingTerms.filter(t => t.searchType === 'keyword');
                  const substringMatches = matchingTerms.filter(t => t.searchType === 'substring');
                  
                  const keywordCount = keywordMatches.reduce((sum, t) => sum + t.count, 0);
                  const substringCount = substringMatches.reduce((sum, t) => sum + t.count, 0);
                  
                  reason = `Found ${totalMatches} total matches outside collect_env.py details section (${keywordCount} keyword matches, ${substringCount} substring matches)`;
                }
              }
              
              core.notice(`Final decision: ${shouldAddLabel ? 'ADD LABEL' : 'DO NOT ADD LABEL'}`);
              core.notice(`Reason: ${reason || 'No matching terms found outside collect_env.py details section'}`);
              
              if (shouldAddLabel) {
                const existingLabels = context.payload.issue.labels.map(l => l.name);
                if (!existingLabels.includes(labelName)) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    labels: [labelName],
                  });
                  core.notice(`Label "${labelName}" added. ${reason}`);
                  return true;
                }
                core.notice(`Label "${labelName}" already present.`);
                return false;
              }
              
              core.notice(`No matching terms found outside collect_env.py details section for label "${labelName}".`);
              return false;
            }
            
            // Process all configured labels
            const processLabels = Object.entries(labelConfig)
              .map(([labelName, config]) => processLabel(labelName, config));
            const labelsAdded = await Promise.all(processLabels);
            const numLabelsAdded = labelsAdded.reduce((x, y) => x + y, 0);
            core.notice(`Processing complete. ${numLabelsAdded} label(s) added.`);