name: Label issues based on keywords
on:
  issues:
    types: [opened, edited, reopened]
permissions:
  issues: write          # needed so the workflow can add labels
  contents: read
concurrency:
  group: issue-labeler-${{ github.event.issue.number }}
  cancel-in-progress: true
jobs:
  add-labels:
    runs-on: ubuntu-latest
    steps:
      - name: Label issues based on keywords
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea  # v7.0.1
        with:
          script: |
            // Configuration: Add new labels and keywords here
            const labelConfig = {
              rocm: {
                keywords: [
                  // Core ROCm/AMD terms
                  "rocm",
                  "roc",
                  "amd",
                  "hip",
                  // GPU Models - Instinct Series
                  "amd instinct",
                  "mi300",
                  "mi300x",
                  "mi300a",
                  "mi250x",
                  "mi250",
                  "mi210x",
                  "mi210",
                  "mi325x",
                  "mi350x",
                  "mi355x",
                  "mi308",
                  // GPU Models - Radeon Series
                  "amd radeon",
                  "ai pro r9700",
                  "rx 9070",
                  "rx 9060",
                  "rx 7900",
                  "rx 7800",
                  // GPU Models - Pro Series
                  "amd radeon pro",
                  "w7900",
                  "w7800",
                  "w7700",
                  "v710",
                  "v620",
                  "w6800",
                  // Architecture codes
                  "cdna3",
                  "cdna2",
                  "cdna4",
                  "cdna",
                  "gfx942",
                  "gfx90a",
                  "gfx1100",
                  "gfx1101",
                  "gfx1201",
                  "gfx1200",
                  "gfx1030",
                  "gfx950",
                  "gfx908",
                  "rdna4",
                  "rdna3",
                  "rdna2",
                  // Libraries and tools
                  "composable kernel",
                  // "aiter", // problem at 13192 aiter is used in langchain
                  "rccl",
                  "migraphx",
                  "hipgraph",
                ],
              },
            };
            
            // Helper function to extract text outside of <details> tags
            function extractTextOutsideDetails(text) {
              // Remove everything between <details> and </details> tags
              return text.replace(/<details[\s\S]*?<\/details>/gi, '');
            }
            
            // Helper function to extract PyTorch Info section from details
            function extractPyTorchInfoFromDetails(text) {
              // Find content within <details> tags
              const detailsMatch = text.match(/<details[\s\S]*?<\/details>/gi);
              if (!detailsMatch) return '';
              
              let pytorchInfo = '';
              for (const details of detailsMatch) {
                // Look for PyTorch Info section
                const pytorchMatch = details.match(/={30}\s*PyTorch Info\s*={30}([\s\S]*?)={30}/i);
                if (pytorchMatch) {
                  pytorchInfo += pytorchMatch[1];
                }
              }
              return pytorchInfo;
            }
            
            // Helper function to check if ROCm has actual version in PyTorch Info
            function hasRocmVersionInPyTorchInfo(pytorchInfoText) {
              const rocmMatch = pytorchInfoText.match(/ROCM used to build PyTorch\s*:\s*(.+)/i);
              if (!rocmMatch) return false;
              
              const rocmValue = rocmMatch[1].trim();
              core.notice(`Found ROCM used to build PyTorch: "${rocmValue}"`);
              
              // Check if it's NOT one of the "no ROCm" values
              const noRocmValues = ['N/A', 'n/a', 'none', 'not available', 'could not collect', '0.0.0'];
              const isNoRocm = noRocmValues.some(val => 
                rocmValue.toLowerCase().includes(val.toLowerCase())
              );
              
              return !isNoRocm && rocmValue.length > 0;
            }
            
            // Helper function to find matching keywords in text
            function findMatchingKeywords(text, keywords) {
              const matches = [];
              for (const keyword of keywords) {
                const regex = new RegExp(`\\b${keyword}\\b`, "gi");
                const keywordMatches = text.match(regex);
                if (keywordMatches) {
                  matches.push({
                    keyword: keyword,
                    matches: keywordMatches,
                    count: keywordMatches.length
                  });
                }
              }
              return matches;
            }
            
            // Helper function to check if label should be added
            async function processLabel(labelName, config) {
              const body = context.payload.issue.body || "";
              const title = context.payload.issue.title || "";
              
              core.notice(`=== DEBUG INFO for label "${labelName}" ===`);
              
              // Extract different parts of the text
              const textOutsideDetails = extractTextOutsideDetails(title + " " + body);
              const pytorchInfoText = extractPyTorchInfoFromDetails(body);
              
              core.notice(`Text outside details length: ${textOutsideDetails.length}`);
              core.notice(`PyTorch info text length: ${pytorchInfoText.length}`);
              
              let shouldAddLabel = false;
              let reason = '';
              
              // Check PyTorch Info section for actual ROCm version
              if (pytorchInfoText) {
                const hasRocmVersion = hasRocmVersionInPyTorchInfo(pytorchInfoText);
                core.notice(`Has ROCm version in PyTorch Info: ${hasRocmVersion}`);
                if (hasRocmVersion) {
                  shouldAddLabel = true;
                  reason = 'ROCm version found in PyTorch Info section';
                }
              }
              
              // Check text outside details for ROCm keywords
              if (!shouldAddLabel && textOutsideDetails) {
                const matchingKeywords = findMatchingKeywords(textOutsideDetails, labelConfig[labelName].keywords);
                if (matchingKeywords.length > 0) {
                  core.notice(`Found ${matchingKeywords.length} matching keyword(s) outside details:`);
                  for (const match of matchingKeywords) {
                    core.notice(`  - Keyword: "${match.keyword}" found ${match.count} time(s)`);
                  }
                  shouldAddLabel = true;
                  reason = 'ROCm keywords found outside details section';
                }
              }
              
              core.notice(`Final decision: ${shouldAddLabel ? 'ADD LABEL' : 'DO NOT ADD LABEL'}`);
              core.notice(`Reason: ${reason || 'No ROCm indicators found'}`);
              core.notice(`=== END DEBUG INFO ===`);
              
              if (shouldAddLabel) {
                const existingLabels = context.payload.issue.labels.map(l => l.name);
                if (!existingLabels.includes(labelName)) {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    labels: [labelName],
                  });
                  core.notice(`Label "${labelName}" added. ${reason}`);
                  return true;
                }
                core.notice(`Label "${labelName}" already present.`);
                return false;
              }
              
              core.notice(`No ROCm indicators found for label "${labelName}".`);
              return false;
            }
            
            // Process all configured labels
            const processLabels = Object.entries(labelConfig)
              .map(([labelName, config]) => processLabel(labelName, config));
            const labelsAdded = await Promise.all(processLabels);
            const numLabelsAdded = labelsAdded.reduce((x, y) => x + y, 0);
            core.notice(`Processing complete. ${numLabelsAdded} label(s) added.`);  